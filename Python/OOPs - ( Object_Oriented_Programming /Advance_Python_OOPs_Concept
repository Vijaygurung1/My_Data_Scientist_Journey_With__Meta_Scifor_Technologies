Question No 1 :- [ # ENCAPSULATION# ENCAPSULATION ]

class Car:
    def __init__(self, brand, model, year):
        # self.__brand = brand  # Encapsulate with double underscore #private attribute
        self.__brand = brand
        self.model = model
        self.year = year

    def get_brand(self):  # Public method to access private attribute
        return self.__brand

    def accelerate(self):
        print(f"The {self.model} is accelerating!")

# Create a Car object
my_car = Car("Tesla", "Model S", 2023)

# Access public attribute
print(my_car.model)  # Output: Model S

print(my_car.get_brand())  # Output: Tesla


# Final Outcome will be ( Model S | Tesla )


Question No 2 :- [ # POLYMORPHISM ]


class Animal: # parent class
    def make_sound(self):
        print("Generic animal sound")

class Dog(Animal): #subclass "dog" inheriting from Animal  #subclasss - dog inherting from "Animal" class
    def make_sound(self):
        print("Woof!")

class Cat(Animal): #subclass "cat" inheriting from parent class "Animal"
    def make_sound(self):
        print("Meow!")

def speak(animal): #speak - method responsible for polymorphism, animal : object
    animal.make_sound()  # Polymorphic behavior

# Create Animal objects
dog = Dog()
cat = Cat()

speak(dog)  # Output: Woof!
speak(cat)  # Output: Meow!

# Final Outcome will be ( Woof | Meow )


Question No 3 :- [ # SINGLE LEVEL INHERITANCE - 1 # Base class / 1 # Dervied class ]

# Base class
class Animal:
    def speak(self):
        print("Animal speaks")

# Derived class
class Dog(Animal):
    def bark(self):
        print("Dog barks")

# Create an instance of Dog
dog = Dog()
dog.speak()  # Inherited method #output - animal speaks
dog.bark()   # Method of Dog class

# The Final outcome will be [ "Animal speaks" | "Dog barks" ]


Question No 4 :- [ # Multi Level Inheritance ]

# Base class #self - use to acessing the instances variables and methods
class Animal:
    def speak(self):
        print("Animal speaks")

# Derived class
class Dog(Animal):
    def bark(self):
        print("Dog barks")

# Further derived class
class Puppy(Dog):
    def cry(self):
        print("Puppy cries")


# Create an instance of Puppy
puppy = Puppy()

puppy.speak()  # Inherited from Animal
puppy.bark()   # Inherited from Dog
puppy.cry()    # Method of Puppy class

# The Final outcome will be -  [ "Animal speaks" | "Dog barks" | "Puppy cries" ]


Question No 5 :-  [ # METHOD OVERRIDING ]

class Animal :
  def make_sound (self) :
    return "generic"

class Dog(Animal):
  def make_sound(self):
    return "woof"

class Cat(Animal):
  def make_sound (self):
    return "meow"

# ques - do all the print statement will get printed in output ?

# make instance+call instance

dog=Dog()
cat=Cat()

print(dog.make_sound())
print(cat.make_sound())

# The Final outcome will be - [ " woof " | " Meow " ]


Question No 6 :-  [ # Multiple Level ]

# Base class 1
class Father:
    def skills(self):
        print("Father's skills")

# Base class 2
class Mother:
    def skills(self):
        print("Mother's skills")

# Derived class
class Child(Father, Mother): #multiple level inheritance going on here!
    def skills(self):
        super().skills()  # Calls the first class in the MRO (Method Resolution Order)
        print("Child's skills")

# Create an instance of Child
child = Child()
mother = Mother()
child.skills()  # This will call Child's skills method

# The Final outcome will be [ "Father's skills" | " Child's skills " ]


Question No 7 :-  [ # Multiple Level ]  # 1st Option :- 

# Base class 1
class Father:
    def skills(self):
        print("Father's skills")

# Base class 2
class Mother:
    def skills(self):
        print("Mother's skills")

# Derived class
class Child(Father, Mother): #multiple level inheritance going on here!
    def skills(self):
        super().skills()  # Calls the first class in the MRO (Method Resolution Order)
        print("Child's skills")

# Create an instance of Child
child = Child()
mother = Mother()
child.skills()  # This will call Child's skills method

The Outcome will be - [ "Father's skills" | "Child's skills" ]


Question No 7 :- [ # Multiple Level ]  # 2nd Option :-


class Parent:
    def skills(self):
        pass  # Placeholder method, will be overridden in subclasses

class Father(Parent):
    def skills(self):
        print("Father's skills")

class Mother(Parent):
    def skills(self):
        print("Mother's skills")

class Child(Father, Mother):
    def skills(self):
        super().skills()  # Calls the first class in the MRO (Method Resolution Order)
        print("Child's skills")

# Creating instances
father = Father()
mother = Mother()
child = Child()

# Output
mother.skills()
child.skills()

# The outcome will be - [ "Mother's skills" | "Father's skills" | "Child's skills" ]


Question No 8 :- [ # Hierarichail ]  

# Base class
class Animal:
    def speak(self):
        print("Animal speaks")

# Derived class 1
class Dog(Animal):
    def bark(self):
        print("Dog barks")

# Derived class 2
class Cat(Animal):
    def meow(self):
        print("Cat meows")

# Create instances of Dog and Cat
dog = Dog()
cat = Cat()

dog.speak()  # Inherited method calls
dog.bark()   # Method of Dog class

cat.speak()  # Inherited method
cat.meow()   # Method of Cat class

# The outcome will be the - [ "Animal speaks" | "Dog barks" | "Animal speaks" | "Cat meows" ]


Question No 9 :- [ # Hybrid Inheritance = [ Combination Multiple Inheritance + Multi-level Inheritance ]


# Base class / name - attribute
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(f"{self.name} makes a sound")

# Single inheritance
class Dog(Animal):
    def speak(self):
        print(f"{self.name} says Woof!")

# Multilevel inheritance
class Puppy(Dog):
    def speak(self):
        print(f"{self.name} says Yip!")

# Another base class
class Bird:
    def __init__(self, name):
        self.name = name

    def fly(self):
        print(f"{self.name} can fly")

# Multiple inheritance
#FLYING DOG - BASE CLASS OR PARENT = INHERITED FROM DOG AND BIRD
class FlyingDog(Dog, Bird):
    def __init__(self, name):
        Dog.__init__(self, name)
        Bird.__init__(self, name)

    def speak(self):
        Dog.speak(self)
        Bird.fly(self)

# Hybrid inheritance
class FlyingPuppy(Puppy, Bird):
    def __init__(self, name):
        Puppy.__init__(self, name)
        Bird.__init__(self, name)

    def speak(self):
        Puppy.speak(self)
        Bird.fly(self)

# Create instances
dog = Dog("Buddy")
puppy = Puppy("Fluffy")
flying_dog = FlyingDog("Sky")
flying_puppy = FlyingPuppy("Wings")

# Test the methods
dog.speak()             # Output: Buddy says Woof!
puppy.speak()           # Output: Fluffy says Yip!
flying_dog.speak()      # Output: Sky says Woof! \n Sky can fly
flying_puppy.speak()

# The outcome will be the -  [ "Buddy says Woof!" | "Fluffy says Yip!" | "Sky says Woof!" | "Sky can fly" | "Wings says Yip!" | "Wings can fly" ]










